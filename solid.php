SOLID-принципы. Если верить определению Wikipedia, это:
аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании 
Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion.

Таким образом, мы имеем 5 принципов, которые и рассмотрим ниже: 

    Принцип единственной ответственности (Single responsibility)	
    Принцип открытости/закрытости (Open-closed)
    Принцип подстановки Барбары Лисков (Liskov substitution)
    Принцип разделения интерфейса (Interface segregation)
	Принцип инверсии зависимостей (Dependency Invertion)
	
	Принцип единственной ответственности гласит :
«На каждый объект должна быть возложена одна единственная обязанность». 
Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.	

	Принцип открытости/закрытости (Open-closed)
Данный принцип гласит — "программные сущности должны быть открыты для расширения, 
но закрыты для модификации". На более простых словах это можно описать так — все классы, 
функции и т.д. должны проектироваться так, чтобы для изменения их поведения, 
нам не нужно было изменять их исходный код.
	(Например есть класс, в котором происходит запрос к БД с помощью Mysql и вдруг базы перенесли на Oracle
	 При этом не нужно будет лезть в код и менять запросы, а этого делать нельзя. Поэтому создается интерфейс, 
	 который реализует 2 подключения)
	
	Принцип подстановки Барбары Лисков (Liskov substitution)
Принцип гласит — «Объекты в программе могут быть заменены их наследниками без изменения свойств программы».
Своими словами я бы это сказал так — при использовании наследника класса результат выполнения кода должен быть предсказуем
и не изменять свойств метод.
	Наследующий класс должен дополнять, а не замещать поведение базового класса.
	(Согласитесь, что глупо замещать большую часть методов, лучше создать новый класс с этим методами)
	Если у нас есть класс A (не виртуальный, а вполне реально используемый в коде) и отнаследованный от него класс B, 
	то если мы заменим все использования класса A на B, ничего не должно измениться в работе программы. 
	Ведь класс B всего лишь расширяет функционал класса A. Если эта проверка работает, то поздравляю: 
	ваша программа соответствует принципу подстановки Лисков! 
	Если нет, стоит уволить ведущего программиста задуматься: «а правильно ли спроектированы классы?». 
	
	Принцип разделения интерфейса (Interface segregation)
Данный принцип гласит, что «Много специализированных интерфейсов лучше, чем один универсальный»
Соблюдение этого принципа необходимо для того, чтобы классы-клиенты использующий/реализующий 
интерфейс знали только о тех методах, которые они используют, что ведёт к уменьшению количества неиспользуемого кода.

	Принцип инверсии зависимостей (Dependency Invertion)
Принцип гласит — «Зависимости внутри системы строятся на основе абстракций. 
Модули верхнего уровня не зависят от модулей нижнего уровня. 
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций». 
Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».
	class SomeClassOne{
		//Есть зависимость, такого быть не должно
		function someMethod(SomeClassTwo class){
			return $class;
		}
		//Зависимости нет. Принцип инверсии зависимостей выполняется
		function someMethod(SomeInterface class){
			return $class;
		}
	}
	
	interface SomeInterface{
		function SomeMethodTwo();
	}
	
	class SomeClassTwo{
		function SomeMethodTwo(){
		}
	}



