# Generator

# Не хранит весь результат в памяти. Выдает результат по частям, при этом чистит предыдущую итерацию
# Генерация происходит по запросу
def make_counter(x):
    print('entering make_counter')
    while True:
        yield x
        print('incrementing x')
        x = x + 1

counter = make_counter(2)
print(counter)
# <generator object make_counter at 0x7fe41eb8d3f0>

print(next(counter))
# entering make_counter
# 2

print(next(counter))
# incrementing x
# 3

print(next(counter))
# incrementing x
# 4

    # Присутствие ключевого слова yield в make_counter означает, что это не обычная функция. Это особый вид функции,
    # которая генерирует значения по одному. Вы можете думать о ней как о продолжаемой функции. Её вызов вернёт генератор,
    # который может быть использован для генерации последующих значений x.

    # Чтобы создать экземпляр генератора make_counter, просто вызовите его как и любую другую функцию. Заметьте, что
    # фактически это не выполняет кода функции. Вы можете так сказать, потому что первая строка функции make_counter()
    # вызывает print(), но ничего до сих пор не напечатано.

    # Функция make_counter() возвращает объект-генератор.

    # Функция next() принимает генератор и возвращает его следующее значение. Первый раз, когда вы вызываете next() с
    # генератором counter, он исполняет код в make_counter() до первого утверждения yield, затем возвращает значение,
    # которое было возвращено yield. В данном случае, это будет 2, поскольку изначально вы создали генератор вызовом
    # make_counter(2).

    # Повторный вызов next() с тем же генератором продолжает вычисления точно там, где они были прерваны, и продолжает до тех пор, пока не встретит следующий yield. Все переменные, локальные состояния и т. д. сохраняются во время yield, и восстанавливаются при вызове next(). Следующая строка кода, ожидающая исполнения, вызывает print(), который печатает incrementing x. После этого следует утверждение x = x + 1. Затем снова исполняется цикл while, и первое, что в нём встречается — утверждение yield x, которое сохраняет все состояние и возвращает текущее значение x (сейчас это 3).
    # После второго вызова next(counter) происходит всё то же самое, только теперь x становится равным 4.





# Генератор последовательности Фибоначчи
def fib(max):
    a, b = 0, 1
    while a < max:
        yield a
        a, b = b, a + b

for n in fib(1000):
    print(n, end=' ')

print(list(fib(1000)))


    # Последовательность Фибоначчи — это последовательность чисел, в которой каждое число является суммой двух предыдущих.
    # Она начинается с 0 и 1, сначала постепенно возрастает, потом растет все быстрее и быстрее. Чтобы начать
    # последовательность, вам необходимо две переменные: а начинает с 0, а b — с 1.

    # a является начальный значением последовательности, поэтому её следует вернуть.

    # b является следующим числом последовательности, так что присвойте ее a, но так же посчитайте следующее значение
    # (a + b) и присвойте его b для последующего использования. Заметьте, что это происходит одновременно.
    # Если a равно 3, а b равно 5, то a, b = b, a + b установит a в 5 (предыдущее значение b) а b в 8 (сумма предыдущих
    # значений a и b).



# Генератор списка состоит из следующих частей:
#
#     входная последовательность
#     переменная, представляющая элементы входной последовательности
#     условие (опционально)
#     выходное выражение, полученное из элементов входного списка, которые удовлетворяют условию

# Допустим, нам нужно получить список всех квадратов целых чисел, которые больше нуля:

num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = []

for number in num:
    if number > 0:
        filtered_and_squared.append(number ** 2)
print(filtered_and_squared)


# Согласитесь, довольно просто? Но это занимает 4-е строчки, 2-у уровня вложенности, и вдобавок мы делаем довольно
# тривиальную вещь. Вы можете уменьшить количество кода с помощью функций filter, lambda и map:
# Работает как генератор

num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = map(lambda x: x ** 2, filter(lambda x: x > 0, num))

for res in filtered_and_squared:
    print(res)

# Теперь код расширяется горизонтально! Что можно сделать, что бы упростить код? Применить генераторы списков.

num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = [ x**2 for x in num if x > 0]
print(filtered_and_squared)


# Генератор списков заключен в квадратные скобки, таким образом, видно что список производится сразу.
# В этом генераторе списка только один вызов функции и нет вызовов загадочной lambda - используется обычный итератор,
# выходное выражение и опциональное условие.

# Но, есть и минусы: результирующий списов вычисляется и сохраняется в память сразу. Это не проблема для небольших
# списков, наподобие приведенных выше, или даже списков на порядок больших. Но иногда это может быть неэффективно.
# Генераторы выручат и сейчас. Выражение-генератор не загружает весь список в память сразу, а вместо этого создает
# объект генератора, поэтому за один раз можно получить только один элемент.

# Выражения-генераторы имеют синтаксис, похожий на синтаксис генераторов списков, только вместо квадратных скобок -
# круглые:

num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = (x**2 for x in num if x > 0)
print(filtered_and_squared)

# <generator object <genexpr> at 0x00583E18>

for item in filtered_and_squared:
    print (item)

# 1, 16, 100 4,9


# Это даже немного эффективнее использования генераторов списков. Заменим пример более эффективным кодом:

num = [1, 4, -5, 10, -7, 2, 3, -1]

def square_generator(list, optional_parameter):
    return (x ** 2 for x in list if x > optional_parameter)

print (square_generator(num, 0))
# <generator object <genexpr> at 0x004E6418>

# Option I
for k in square_generator(num, 0):
    print (k)
# 1, 16, 100, 4, 9

# Option II
g = list(square_generator(num, 0))
print (g)
# [1, 16, 100, 4, 9]


# Так же, вы можете использовать функцию zip для работы с двумя и более элементами за раз:

alist = ['a1', 'a2', 'a3']
blist = ['1', '2', '3']

g = zip(alist, blist)

print(g)

for a, b in g:
    print (a, b)

# a1 1
# a2 2
# a3 3


