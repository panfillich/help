<?php 

//Singleton (Синглтон, одиночка) относиться к классу порождающих паттернов.
//Основное назначение – гарантировать существование только одно экземпляра класса.
//И гарантирует, что во время работы программы не появиться второй. 
//Например в схеме MVC, зачастую этот паттерн используется для порождения главного контроллера (фронтового), 
//коннект к БД и прочие

class Singleton{
	//prop - свойства
	private $props = array();
	//instance - экземпляр обьекта
	protected static $_instance = null;

	public function __construct(){
		//Закрываем конструктор
	}
	
	public function __clone(){
		//Убираем возможность клонирования экземпляра
	}
	
	public static function getInstance(){
		if(self::$_instance === null){
			self::$_instance = new Singleton;
		}
		return self::$_instance;
	}
	
	public function setProperty( $key, $val ){
		$this -> props[$key] = $val;
	}
	
	public function getProperty( $key ){
		return $this->props[$key];
	}
}

$pref =  Singleton::getInstance();
$pref -> setProperty ("name","Иван");
unset($pref); //Удалим ссылку
$pref2 = Singleton::getinstance() ;
//Убедимся , что ранее установленное значение сохранено
print $pref2->getProperty ( "name" ) . " \n "; //Выводит Иван Profit))


//Выводы плохого. И шаблоном Singleton, и глобальными переменными часто злоупотребляют. 
//Поскольку доступ к объектам Singleton можно получить из любого места системы, 
//они могут способствовать созданию зависимостей

//В конце концов, мы создаем зависимость
//каждый раз, когда объявляем, что методу требуется передать аргумент определенного
//типа. Проблема в том, что глобальная природа шаблона Singleton позволяет
//программисту обойти каналы коммуникации, определенные интерфейсами класса.
//Когда используется Singleton, зависимость скрыта внутри метода и не объявляется
//в его сигнатуре. Это затрудняет отслеживание связей внутри системы. Поэтому
//классы Singleton должны использоваться редко и очень осторожно.